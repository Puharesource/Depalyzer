namespace Depalyzer.Cli;

using System.Collections.Immutable;
using System.Text.Json;
using System.Text.RegularExpressions;
using Depalyzer.Cli.Commands;
using Depalyzer.Cli.DataHandlers;
using Depalyzer.Cli.Helpers;
using Depalyzer.Cli.Process;
using Depalyzer.Common.Models.VulnerabilityCheck;
using Depalyzer.Common.Tree;
using Microsoft.Build.Construction;
using Spectre.Console;
using Package = Depalyzer.Common.Models.Package;

public partial class VulnerabilityScanner(DepalyzerCommand.Settings settings)
{
    public async Task Scan()
    {
        var solutionPath = SolutionHelper.GetProjectOrSolution(settings.FullPathDirectory);
        var solution = SolutionHelper.GetSolutionFileForDirectoryOrFile(solutionPath);

        AnsiConsoleHelper.WriteLine(
            new Markup($"Scanning solution {Markup.Escape(Path.GetFileNameWithoutExtension(solutionPath))} with {solution.FilteredProjectsInOrder().Count} projects."));

        await this.Restore();
        var vulnerabilityCheckOutput = await this.ScanVulnerabilities(solutionPath);

        if (settings.IsVerbose)
        {
            var solutionProjectsPanel = new Panel(new Rows(solution.FilteredProjectsInOrder().Select(project => new Text(project.ProjectName))))
                .Header("Solution Projects")
                .RoundedBorder()
                .BorderColor(Color.Yellow);

            var vulnerabilityCheckProjectsPanel = new Panel(new Rows(vulnerabilityCheckOutput.Projects.Select(project => new Text(project.Name))))
                .Header("Vulnerability Check Projects")
                .RoundedBorder()
                .BorderColor(Color.Yellow);

            solutionProjectsPanel.Expand = true;
            vulnerabilityCheckProjectsPanel.Expand = true;

            AnsiConsoleHelper.WriteLine(solutionProjectsPanel);
            AnsiConsoleHelper.WriteLine(vulnerabilityCheckProjectsPanel);
        }

        foreach (var project in vulnerabilityCheckOutput.Projects)
        {
            var solutionProject = solution.ProjectsInOrder.First(solutionProject => IsSolutionProjectSameAsProject(solutionProject, project));
            var tree = new Tree($"Project [bold]{Markup.Escape(project.Name)}[/] has the following vulnerable packages").Guide(TreeGuide.Line);
            var projectAssets = await ScanAssets(solutionProject.AbsoluteDirectory());
            var projectAssetsDataHandler = new ProjectAssetsDataHandler(projectAssets);

            if (project.Frameworks is null)
            {
                AnsiConsoleHelper.WriteLine(new Markup($"No vulnerabilities found for project [bold]{Markup.Escape(project.Name)}[/]."));

                continue;
            }

            foreach (var framework in project.Frameworks)
            {
                var node = tree.AddNode($"[blue][[{Markup.Escape(framework.Sdk)}]]:[/]");
                var targetDataHandler = projectAssetsDataHandler.GetTarget(framework.Sdk);

                var transitivePackageTree = this.BuildTransitivePackageTree(vulnerabilityCheckOutput.Projects, framework.TransitivePackages, targetDataHandler);

                DrawPackageTree(node, framework.Packages);
                DrawTransitivePackageTree(node, transitivePackageTree, framework.TransitivePackages ?? ImmutableArray<Common.Models.VulnerabilityCheck.Package>.Empty);
            }

            AnsiConsoleHelper.WriteLine(tree);
        }
    }

    private static bool IsSolutionProjectSameAsProject(ProjectInSolution solutionProject, Project project)
    {
        var solutionProjectName = solutionProject.ProjectName;

        if (solutionProjectName.Equals(project.Name, StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }

        if (!solutionProjectName.Contains('/'))
        {
            return false;
        }

        solutionProjectName = solutionProject.ProjectName.Split('/', 2)[1];

        return solutionProjectName.Equals(project.Name, StringComparison.OrdinalIgnoreCase);
    }

    private TreeNode<Package> BuildTransitivePackageTree(
        ImmutableArray<Project> projects,
        ImmutableArray<Common.Models.VulnerabilityCheck.Package>? packages,
        ProjectAssetsTargetDataHandler targetDataHandler)
    {
        var root = new TreeNode<Package>(new("Endnu en N/A", "1.1.1"));
        if (packages is null)
        {
            return root;
        }

        var allLeaves = new List<TreeNode<Package>>();
        foreach (var transitivePackage in packages)
        {
            var parents = targetDataHandler.FindAllParents(transitivePackage.Id, transitivePackage.ResolvedVersion);
            var leaves = TreeHelper.FindLeaves(parents);

            allLeaves.AddRange(leaves);
        }

        var tree = TreeHelper.MergeLeavesIntoTree(allLeaves.ToImmutableArray());
        root.AddNodes(tree.Children.Where(child => settings.IsShowingProjectsInTransitive || projects.All(project => project.Name != child.Item.Name)));

        if (settings.IsSimplifiedView)
        {
            root = CollapseTreeToVulnerablePackages(root, (ImmutableArray<Common.Models.VulnerabilityCheck.Package>)packages);
        }

        return root;
    }

    private static void DrawPackageTree(TreeNode node, ImmutableArray<Common.Models.VulnerabilityCheck.Package>? packages)
    {
        node = node.AddNode("[underline]Top Level Packages[/]");

        if (packages is null or { Length: 0 })
        {
            node.AddNode("[bold]No top level package vulnerabilities found.[/]");
            return;
        }

        foreach (var package in packages)
        {
            var vulnerability = package.Vulnerabilities.First();

            node.AddNode($"[{vulnerability.Severity.GetColor()}]{vulnerability.Severity}[/] {Markup.Escape(package.Id)}/{Markup.Escape(package.ResolvedVersion)}");
        }
    }

    private static void DrawTransitivePackageTree(
        TreeNode node,
        TreeNode<Package> treeNode,
        ImmutableArray<Common.Models.VulnerabilityCheck.Package> vulnerabilityCheckPackages,
        int depth = 0)
    {
        if (depth == 0)
        {
            node = node.AddNode("[underline]Transitive Packages[/]");

            if (treeNode.Children.Count == 0)
            {
                node.AddNode("[bold]No transitive vulnerabilities found.[/]");
                return;
            }
        }

        foreach (var transitivePackage in treeNode.Children)
        {
            var package = transitivePackage.Item;
            var vulnerability = vulnerabilityCheckPackages
                .Cast<Common.Models.VulnerabilityCheck.Package?>()
                .FirstOrDefault(
                    vulnerabilityCheckPackage => vulnerabilityCheckPackage!.Value.Id == package.Name && vulnerabilityCheckPackage.Value.ResolvedVersion == package.Version)
                ?.Vulnerabilities
                .FirstOrDefault();
            var prefix = vulnerability is null ? string.Empty : $"[{vulnerability.Value.Severity.GetColor()}]{vulnerability.Value.Severity}[/] ";

            var packageString = depth == 0 || vulnerability is not null ? $"[bold]{Markup.Escape(package.Name)}/{Markup.Escape(package.Version)}[/]"
                : $"{package.Name}/{package.Version}";

            var childNode = node.AddNode(prefix + packageString);
            DrawTransitivePackageTree(childNode, transitivePackage, vulnerabilityCheckPackages, depth + 1);
        }
    }

    private static ImmutableArray<TreeNode<Package>> FindVulnerableChildNodes(
        TreeNode<Package> previousNode,
        ImmutableArray<Common.Models.VulnerabilityCheck.Package> vulnerabilityCheckPackages)
    {
        var roots = new List<TreeNode<Package>>();
        var package = previousNode.Item;
        var vulnerability = vulnerabilityCheckPackages
            .Cast<Common.Models.VulnerabilityCheck.Package?>()
            .FirstOrDefault(vulnerabilityCheckPackage => vulnerabilityCheckPackage!.Value.Id == package.Name && vulnerabilityCheckPackage.Value.ResolvedVersion == package.Version)
            ?.Vulnerabilities
            .FirstOrDefault();

        if (!previousNode.IsRoot && vulnerability is not null)
        {
            roots.Add(previousNode);
        }

        foreach (var foundRoots in previousNode.Children.Select(child => FindVulnerableChildNodes(child, vulnerabilityCheckPackages)))
        {
            roots.AddRange(foundRoots);
        }

        return roots.ToImmutableArray();
    }

    public static TreeNode<Package> CollapseTreeToVulnerablePackages(TreeNode<Package> root, ImmutableArray<Common.Models.VulnerabilityCheck.Package> vulnerabilityCheckPackages)
    {
        var newRoot = new TreeNode<Package>(root.Item);

        foreach (var child in root.Children)
        {
            var node = newRoot.AddOrGetNodeFor(child.Item);
            var foundLeaves = FindVulnerableChildNodes(child, vulnerabilityCheckPackages);

            foreach (var foundLeaf in foundLeaves)
            {
                node.AddOrGetNodeFor(foundLeaf.Item);
            }
        }

        return newRoot;
    }

    private async Task Restore()
    {
        var output = await ConsoleHelper.RunCommand(
            workingDirectory: settings.FullPathDirectory,
            fileName: "dotnet",
            arguments: "restore --locked-mode --force",
            monkey: settings.IsUsingMonkeySpinner);

        var lines = output.Split(
            ["\r\n", "\r", "\n"],
            StringSplitOptions.None);

        foreach (var line in lines)
        {
            var match = RestoreOutputRegex().Match(line);

            if (match.Success)
            {
                AnsiConsoleHelper.WriteLine(new Markup($"Restored [yellow]{Markup.Escape(match.Groups[1].Value)}[/] in [yellow]{Markup.Escape(match.Groups[2].Value)}[/]."));
            }
        }
    }

    private async Task<Root> ScanVulnerabilities(string fileOrDirectory)
    {
        var output = await ConsoleHelper.RunCommand(
            workingDirectory: settings.FullPathDirectory,
            fileName: "dotnet",
            arguments: $"""list "{fileOrDirectory}" package --vulnerable --include-transitive --format json""",
            monkey: settings.IsUsingMonkeySpinner);

        if (settings.IsVerbose)
        {
            AnsiConsoleHelper.WriteLine(
                new Panel(new Text(output))
                    .Header("Vulnerability Check Output")
                    .RoundedBorder()
                    .BorderColor(Color.Yellow));
        }

        var vulnerabilityCheckOutput = JsonSerializer.Deserialize<Root>(output);

        AnsiConsole.WriteLine("Finished scanning vulnerabilities.");

        return vulnerabilityCheckOutput;
    }

    private static async Task<Common.Models.ProjectAssets.Root> ScanAssets(string directory)
    {
        var projectAssetsJson = await File.ReadAllTextAsync($@"{directory}\obj\project.assets.json");

        return JsonSerializer.Deserialize<Common.Models.ProjectAssets.Root>(projectAssetsJson);
    }

    [GeneratedRegex(@"Restored .*\\(.*)\.csproj \(in (\d+ \w+)\)\.")]
    private static partial Regex RestoreOutputRegex();
}